/*
 * Copyright (C) 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include <vulkan/vk_layer.h>
#include <cstring>
#include "layer.h"
namespace graphicsfuzz_amber_scoop {
    Context &GetGlobalContext() {
        static Context kContext;
        return kContext;
    }
    namespace wrapped {
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateBuffer(VkDevice device, VkBufferCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkBuffer* pBuffer) {
            PFN_vkCreateBuffer fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateBuffer;
            return graphicsfuzz_amber_scoop::vkCreateBuffer(fn, device, pCreateInfo, pAllocator, pBuffer);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateCommandPool(VkDevice device, VkCommandPoolCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkCommandPool* pCommandPool) {
            PFN_vkCreateCommandPool fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateCommandPool;
            return graphicsfuzz_amber_scoop::vkCreateCommandPool(fn, device, pCreateInfo, pAllocator, pCommandPool);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy const* pRegions) {
            PFN_vkCmdCopyBuffer fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdCopyBuffer;
            return graphicsfuzz_amber_scoop::vkCmdCopyBuffer(fn, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy const* pRegions) {
            PFN_vkCmdCopyBufferToImage fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdCopyBufferToImage;
            return graphicsfuzz_amber_scoop::vkCmdCopyBufferToImage(fn, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateDescriptorSetLayout(VkDevice device, VkDescriptorSetLayoutCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkDescriptorSetLayout* pSetLayout) {
            PFN_vkCreateDescriptorSetLayout fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateDescriptorSetLayout;
            return graphicsfuzz_amber_scoop::vkCreateDescriptorSetLayout(fn, device, pCreateInfo, pAllocator, pSetLayout);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkAllocateDescriptorSets(VkDevice device, VkDescriptorSetAllocateInfo const* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
            PFN_vkAllocateDescriptorSets fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkAllocateDescriptorSets;
            return graphicsfuzz_amber_scoop::vkAllocateDescriptorSets(fn, device, pAllocateInfo, pDescriptorSets);
        }
        VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet const* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet const* pDescriptorCopies) {
            PFN_vkUpdateDescriptorSets fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkUpdateDescriptorSets;
            return graphicsfuzz_amber_scoop::vkUpdateDescriptorSets(fn, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet const* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t const* pDynamicOffsets) {
            PFN_vkCmdBindDescriptorSets fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdBindDescriptorSets;
            return graphicsfuzz_amber_scoop::vkCmdBindDescriptorSets(fn, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void const* pValues) {
            PFN_vkCmdPushConstants fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdPushConstants;
            return graphicsfuzz_amber_scoop::vkCmdPushConstants(fn, commandBuffer, layout, stageFlags, offset, size, pValues);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
            PFN_vkCmdBindIndexBuffer fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdBindIndexBuffer;
            return graphicsfuzz_amber_scoop::vkCmdBindIndexBuffer(fn, commandBuffer, buffer, offset, indexType);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer const* pBuffers, VkDeviceSize const* pOffsets) {
            PFN_vkCmdBindVertexBuffers fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdBindVertexBuffers;
            return graphicsfuzz_amber_scoop::vkCmdBindVertexBuffers(fn, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
            PFN_vkCmdDraw fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdDraw;
            return graphicsfuzz_amber_scoop::vkCmdDraw(fn, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
            PFN_vkCmdDrawIndexed fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdDrawIndexed;
            return graphicsfuzz_amber_scoop::vkCmdDrawIndexed(fn, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateImage(VkDevice device, VkImageCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkImage* pImage) {
            PFN_vkCreateImage fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateImage;
            return graphicsfuzz_amber_scoop::vkCreateImage(fn, device, pCreateInfo, pAllocator, pImage);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateSampler(VkDevice device, VkSamplerCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkSampler* pSampler) {
            PFN_vkCreateSampler fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateSampler;
            return graphicsfuzz_amber_scoop::vkCreateSampler(fn, device, pCreateInfo, pAllocator, pSampler);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreatePipelineLayout(VkDevice device, VkPipelineLayoutCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkPipelineLayout* pPipelineLayout) {
            PFN_vkCreatePipelineLayout fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreatePipelineLayout;
            return graphicsfuzz_amber_scoop::vkCreatePipelineLayout(fn, device, pCreateInfo, pAllocator, pPipelineLayout);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo const* pCreateInfos, AllocationCallbacks pAllocator, VkPipeline* pPipelines) {
            PFN_vkCreateGraphicsPipelines fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateGraphicsPipelines;
            return graphicsfuzz_amber_scoop::vkCreateGraphicsPipelines(fn, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateShaderModule(VkDevice device, VkShaderModuleCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkShaderModule* pShaderModule) {
            PFN_vkCreateShaderModule fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateShaderModule;
            return graphicsfuzz_amber_scoop::vkCreateShaderModule(fn, device, pCreateInfo, pAllocator, pShaderModule);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
            PFN_vkCmdBindPipeline fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdBindPipeline;
            return graphicsfuzz_amber_scoop::vkCmdBindPipeline(fn, commandBuffer, pipelineBindPoint, pipeline);
        }
        VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
            PFN_vkGetPhysicalDeviceMemoryProperties fn = GetGlobalContext().GetVkPhysicalDeviceData(physicalDevice)->functions->vkGetPhysicalDeviceMemoryProperties;
            return graphicsfuzz_amber_scoop::vkGetPhysicalDeviceMemoryProperties(fn, physicalDevice, pMemoryProperties);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkQueueSubmit(VkQueue queue, uint32_t submitCount, VkSubmitInfo const* pSubmits, VkFence fence) {
            PFN_vkQueueSubmit fn = GetGlobalContext().GetVkQueueData(queue)->functions->vkQueueSubmit;
            return graphicsfuzz_amber_scoop::vkQueueSubmit(fn, queue, submitCount, pSubmits, fence);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateFramebuffer(VkDevice device, VkFramebufferCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkFramebuffer* pFramebuffer) {
            PFN_vkCreateFramebuffer fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateFramebuffer;
            return graphicsfuzz_amber_scoop::vkCreateFramebuffer(fn, device, pCreateInfo, pAllocator, pFramebuffer);
        }
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateRenderPass(VkDevice device, VkRenderPassCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkRenderPass* pRenderPass) {
            PFN_vkCreateRenderPass fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateRenderPass;
            return graphicsfuzz_amber_scoop::vkCreateRenderPass(fn, device, pCreateInfo, pAllocator, pRenderPass);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassContents contents) {
            PFN_vkCmdBeginRenderPass fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdBeginRenderPass;
            return graphicsfuzz_amber_scoop::vkCmdBeginRenderPass(fn, commandBuffer, pRenderPassBegin, contents);
        }
        VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers) {
            PFN_vkCmdPipelineBarrier fn = GetGlobalContext().GetVkCommandBufferData(commandBuffer)->functions->vkCmdPipelineBarrier;
            return graphicsfuzz_amber_scoop::vkCmdPipelineBarrier(fn, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        }
    }
    namespace internal {
        namespace {
            template <typename T>
            struct link_info_traits {
                const static bool is_instance =
                std::is_same<T, const VkInstanceCreateInfo>::value;
                using layer_info_type =
                typename std::conditional<is_instance, VkLayerInstanceCreateInfo,
                VkLayerDeviceCreateInfo>::type;
                const static VkStructureType sType =
                is_instance ? VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO
                : VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
            };
            // Get layer_specific data for this layer.
            // Will return either VkLayerInstanceCreateInfo or
            // VkLayerDeviceCreateInfo depending on the type of the pCreateInfo
            // passed in.
            template <typename T>
            typename link_info_traits<T>::layer_info_type *get_layer_link_info(
            T *pCreateInfo) {
                using layer_info_type = typename link_info_traits<T>::layer_info_type;
                auto layer_info = const_cast<layer_info_type *>(
                static_cast<const layer_info_type *>(pCreateInfo->pNext));
                while (layer_info) {
                    if (layer_info->sType == link_info_traits<T>::sType &&
                    layer_info->function == VK_LAYER_LINK_INFO) {
                        return layer_info;
                    }
                    layer_info = const_cast<layer_info_type *>(
                    static_cast<const layer_info_type *>(layer_info->pNext));
                }
                return layer_info;
            }
        }
        static const VkLayerProperties global_layer_properties[] = { {
                "VK_LAYER_GRAPHICSFUZZ_amber_scoop",
                VK_VERSION_MAJOR(1) | VK_VERSION_MINOR(0) | 5,
                1,
                "",
            } };
        VKAPI_ATTR VkResult VKAPI_CALL get_layer_properties(uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            if (pProperties == NULL) {
                *pPropertyCount = 1;
                return VK_SUCCESS;
            }
            if (pPropertyCount == 0) {
                return VK_INCOMPLETE;
            }
            *pPropertyCount = 1;
            memcpy(pProperties, global_layer_properties, sizeof(global_layer_properties));
            return VK_SUCCESS;
        }
        VKAPI_ATTR VkResult VKAPI_CALL physical_device_layer_properties(
        VkPhysicalDevice,
        uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            return get_layer_properties(pPropertyCount, pProperties);
        }
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            PFN_vkEnumerateInstanceLayerProperties next = &get_layer_properties;
            return (VkResult) next(pPropertyCount, pProperties);
        }
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateDeviceLayerProperties(VkPhysicalDevice device, uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            PFN_vkEnumerateDeviceLayerProperties next = &physical_device_layer_properties;
            return (VkResult) next(device, pPropertyCount, pProperties);
        }
        // Overload vkEnumerateInstanceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        enumerate_instance_layer_properties(
        const char *, uint32_t * pPropertyCount,
        VkExtensionProperties *) {
            *pPropertyCount = 0;
            return VK_SUCCESS;
        }
        // Overload vkEnumerateInstanceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateInstanceExtensionProperties(
        const char * pLayerName, uint32_t *pPropertyCount,
        VkExtensionProperties * pProperties) {
            PFN_vkEnumerateInstanceExtensionProperties next = &enumerate_instance_layer_properties;
            return next(pLayerName, pPropertyCount, pProperties);
        }
        // Overload vkEnumerateDeviceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateDeviceExtensionProperties(
        VkPhysicalDevice device,
        const char * pLayerName, uint32_t *pPropertyCount,
        VkExtensionProperties * pProperties) {
            if (!device) { return VK_SUCCESS; }
            auto instance = GetGlobalContext().GetVkPhysicalDeviceData(device)->instance;
            PFN_vkEnumerateDeviceExtensionProperties next = GetGlobalContext().GetVkInstanceData(instance)->enumerate_device_extension_properties;
            return next(device, pLayerName, pPropertyCount, pProperties);
            *pPropertyCount = 0;
            return VK_SUCCESS;
        }
        // Overload vkCreateInstance. It is all book-keeping
        // and passthrough to the next layer (or ICD) in the chain.
        VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
        const VkInstanceCreateInfo *pCreateInfo,
        const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) {
            VkLayerInstanceCreateInfo *layer_info = get_layer_link_info(pCreateInfo);
            // Grab the pointer to the next vkGetInstanceProcAddr in the chain.
            PFN_vkGetInstanceProcAddr get_instance_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetInstanceProcAddr;
            // From that get the next vkCreateInstance function.
            PFN_vkCreateInstance create_instance = reinterpret_cast<PFN_vkCreateInstance>(
            get_instance_proc_addr(NULL, "vkCreateInstance"));
            if (create_instance == NULL) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            // The next layer may read from layer_info,
            // so advance the pointer for it.
            layer_info->u.pLayerInfo = layer_info->u.pLayerInfo->pNext;
            VkResult result = create_instance(pCreateInfo, pAllocator, pInstance);
            // If it failed, then we don't need to track this instance.
            if (result != VK_SUCCESS) return result;
            PFN_vkEnumeratePhysicalDevices enumerate_physical_devices =
            reinterpret_cast<PFN_vkEnumeratePhysicalDevices>(
            get_instance_proc_addr(*pInstance, "vkEnumeratePhysicalDevices"));
            if (!enumerate_physical_devices) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            PFN_vkEnumerateDeviceExtensionProperties
            enumerate_device_extension_properties =
            reinterpret_cast<PFN_vkEnumerateDeviceExtensionProperties>(
            get_instance_proc_addr(*pInstance,
            "vkEnumerateDeviceExtensionProperties"));
            if (!enumerate_device_extension_properties) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            InstanceData data;
            data.get_instance_proc_addr = get_instance_proc_addr;
            data.enumerate_physical_devices = enumerate_physical_devices;
            data.create_device = reinterpret_cast<PFN_vkCreateDevice>(
            get_instance_proc_addr(*pInstance, "vkCreateDevice"));
            data.destroy_instance = reinterpret_cast<PFN_vkDestroyInstance>(
            get_instance_proc_addr(*pInstance, "vkDestroyInstance"));
            data.enumerate_device_extension_properties = enumerate_device_extension_properties;
            data.functions = new InstanceFunctions();
            #define GET_PROC(name) \
            data.functions->name =          \
            reinterpret_cast<PFN_##name>(get_instance_proc_addr(*pInstance, #name))
            // Overrides
            GET_PROC(vkGetPhysicalDeviceMemoryProperties);
            // Called Functions
            #undef GET_PROC
            // Add this instance, along with the vkGetInstanceProcAddr to our
            // map. This way when someone calls vkGetInstanceProcAddr, we can forward
            // it to the correct "next" vkGetInstanceProcAddr.
            {
                auto instances = GetGlobalContext().GetVkInstanceMap();
                // The same instance was returned twice, this is a problem.
                if (instances->find(*pInstance) != instances->end()) {
                    return VK_ERROR_INITIALIZATION_FAILED;
                }
                (*instances)[*pInstance] = data;
            }
            {
                auto instance = *pInstance;
                std::vector<VkPhysicalDevice> devices;
                uint32_t device_count = 0;
                enumerate_physical_devices(*pInstance, &device_count, nullptr);
                devices.resize(device_count);
                enumerate_physical_devices(*pInstance, &device_count, devices.data());
                auto instanceFunctions = GetGlobalContext().GetVkInstanceData(instance)->functions;
                auto create_device = GetGlobalContext().GetVkInstanceData(instance)->create_device;
                auto physicalDevices = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (size_t i = 0; i < device_count; ++i) {
                    PhysicalDeviceData dat;
                    dat.create_device = create_device;
                    dat.functions = instanceFunctions;
                    dat.instance = instance;
                    if (physicalDevices->find(devices[i]) != physicalDevices->end()) {
                        continue;
                    }
                    (*physicalDevices)[devices[i]] = dat;
                }
            }
            return result;
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
        VkInstance        instance,
        uint32_t*         pPhysicalDeviceCount,
        VkPhysicalDevice* pPhysicalDevices) {
            PFN_vkEnumeratePhysicalDevices next =
            GetGlobalContext().GetVkInstanceData(instance)->enumerate_physical_devices;
            VkResult res = (VkResult) next(instance, pPhysicalDeviceCount, pPhysicalDevices);
            if (pPhysicalDevices == nullptr) {
                return res;
            }
            if (res != VK_SUCCESS && res != VK_INCOMPLETE) {
                return res;
            }
            {
                auto instanceFunctions = GetGlobalContext().GetVkInstanceData(instance)->functions;
                auto create_device = GetGlobalContext().GetVkInstanceData(instance)->create_device;
                auto physicalDevices = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (size_t i = 0; i < *pPhysicalDeviceCount; ++i) {
                    PhysicalDeviceData dat;
                    dat.create_device = create_device;
                    dat.functions = instanceFunctions;
                    dat.instance = instance;
                    if (physicalDevices->find(pPhysicalDevices[i]) != physicalDevices->end()) {
                        continue;
                    }
                    (*physicalDevices)[pPhysicalDevices[i]] = dat;
                }
            }
            return res;
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
        VkPhysicalDevice             physicalDevice,
        const VkDeviceCreateInfo*    pCreateInfo,
        AllocationCallbacks          pAllocator,
        VkDevice*                    pDevice) {
            VkLayerDeviceCreateInfo *layer_info = get_layer_link_info(pCreateInfo);
            // Grab the fpGetInstanceProcAddr from the layer_info. We will get
            // vkCreateDevice from this.
            // Note: we cannot use our instance_map because we do not have a
            // vkInstance here.
            PFN_vkGetInstanceProcAddr get_instance_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetInstanceProcAddr;
            auto instance = GetGlobalContext().GetVkPhysicalDeviceData(physicalDevice)->instance;
            PFN_vkCreateDevice next = reinterpret_cast<PFN_vkCreateDevice>(
            get_instance_proc_addr(instance, "vkCreateDevice"));
            if (!next) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            // We want to store off the next vkGetDeviceProcAddr so keep track of it now
            // before we advance the pointer.
            PFN_vkGetDeviceProcAddr get_device_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetDeviceProcAddr;
            // The next layer may read from layer_info,
            // so advance the pointer for it.
            layer_info->u.pLayerInfo = layer_info->u.pLayerInfo->pNext;
            VkResult res = (VkResult) next(physicalDevice, pCreateInfo, pAllocator, pDevice);
            if (res != VK_SUCCESS) {
                return res;
            }
            DeviceData data;
            data.functions = new DeviceFunctions();
            data.physical_device = physicalDevice;
            data.instance = instance;
            data.get_device_proc_addr = get_device_proc_addr;
            data.allocate_command_buffers = reinterpret_cast<PFN_vkAllocateCommandBuffers>(get_device_proc_addr(*pDevice, "vkAllocateCommandBuffers"));
            data.get_device_queue = reinterpret_cast<PFN_vkGetDeviceQueue>(get_device_proc_addr(*pDevice, "vkGetDeviceQueue"));
            data.destroy_device = reinterpret_cast<PFN_vkDestroyDevice>(get_device_proc_addr(*pDevice, "vkDestroyDevice"));
            data.free_command_buffers = reinterpret_cast<PFN_vkFreeCommandBuffers>(get_device_proc_addr(*pDevice, "vkFreeCommandBuffers"));
            data.destroy_command_pool = reinterpret_cast<PFN_vkDestroyCommandPool>(get_device_proc_addr(*pDevice, "vkDestroyCommandPool"));
            #define GET_PROC(name) \
            data.functions->name =          \
            reinterpret_cast<PFN_##name>(get_device_proc_addr(*pDevice, #name))
            // Overrides
            GET_PROC(vkCreateBuffer);
            GET_PROC(vkCreateCommandPool);
            GET_PROC(vkCmdCopyBuffer);
            GET_PROC(vkCmdCopyBufferToImage);
            GET_PROC(vkCreateDescriptorSetLayout);
            GET_PROC(vkAllocateDescriptorSets);
            GET_PROC(vkUpdateDescriptorSets);
            GET_PROC(vkCmdBindDescriptorSets);
            GET_PROC(vkCmdPushConstants);
            GET_PROC(vkCmdBindIndexBuffer);
            GET_PROC(vkCmdBindVertexBuffers);
            GET_PROC(vkCmdDraw);
            GET_PROC(vkCmdDrawIndexed);
            GET_PROC(vkCreateImage);
            GET_PROC(vkCreateSampler);
            GET_PROC(vkCreatePipelineLayout);
            GET_PROC(vkCreateGraphicsPipelines);
            GET_PROC(vkCreateShaderModule);
            GET_PROC(vkCmdBindPipeline);
            GET_PROC(vkQueueSubmit);
            GET_PROC(vkCreateFramebuffer);
            GET_PROC(vkCreateRenderPass);
            GET_PROC(vkCmdBeginRenderPass);
            GET_PROC(vkCmdPipelineBarrier);
            // Called Functions
            #undef GET_PROC
            {
                auto devices = GetGlobalContext().GetVkDeviceMap();
                (*devices)[*pDevice] = data;
            }
            return res;
        }
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
        vkGetDeviceProcAddr(VkDevice device, const char *pName);
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
        const VkInstance  instance,
        const char* pName) {
            if (strcmp(pName, "vkCreateInstance") == 0) {
                return (PFN_vkVoidFunction)(internal::vkCreateInstance);
            }
            if (strcmp(pName, "vkEnumerateInstanceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)(internal::vkEnumerateInstanceExtensionProperties);
            }
            if (strcmp(pName, "vkEnumerateInstanceLayerProperties") == 0 ) {
                return (PFN_vkVoidFunction)(internal::vkEnumerateInstanceLayerProperties);
            }
            if (strcmp(pName, "vkEnumerateDeviceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)internal::vkEnumerateDeviceExtensionProperties;
            }
            if (strcmp(pName, "vkGetInstanceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetInstanceProcAddr;
            }
            if (strcmp(pName, "vkGetDeviceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceProcAddr;
            }
            if (instance == 0) {
                return nullptr;
            }
            if (strcmp(pName, "vkEnumeratePhysicalDevices") == 0) {
                return (PFN_vkVoidFunction)(internal::vkEnumeratePhysicalDevices);
            }
            if (strcmp(pName, "vkCreateDevice") == 0) {
                return (PFN_vkVoidFunction)(internal::vkCreateDevice);
            }
            PFN_vkGetInstanceProcAddr instance_proc_addr =
            GetGlobalContext().GetVkInstanceData(instance)->get_instance_proc_addr;
            auto fn = instance_proc_addr(instance, pName);
            #define INTERCEPT(func)         \
            if ((strcmp(pName, #func) == 0) && fn) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_amber_scoop::wrapped::func);
            #define ALWAYS_INTERCEPT(func)  \
            if (strcmp(pName, #func) == 0) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_amber_scoop::wrapped::func);
            INTERCEPT(vkCreateBuffer);
            INTERCEPT(vkCreateCommandPool);
            INTERCEPT(vkCmdCopyBuffer);
            INTERCEPT(vkCmdCopyBufferToImage);
            INTERCEPT(vkCreateDescriptorSetLayout);
            INTERCEPT(vkAllocateDescriptorSets);
            INTERCEPT(vkUpdateDescriptorSets);
            INTERCEPT(vkCmdBindDescriptorSets);
            INTERCEPT(vkCmdPushConstants);
            INTERCEPT(vkCmdBindIndexBuffer);
            INTERCEPT(vkCmdBindVertexBuffers);
            INTERCEPT(vkCmdDraw);
            INTERCEPT(vkCmdDrawIndexed);
            INTERCEPT(vkCreateImage);
            INTERCEPT(vkCreateSampler);
            INTERCEPT(vkCreatePipelineLayout);
            INTERCEPT(vkCreateGraphicsPipelines);
            INTERCEPT(vkCreateShaderModule);
            INTERCEPT(vkCmdBindPipeline);
            INTERCEPT(vkGetPhysicalDeviceMemoryProperties);
            INTERCEPT(vkQueueSubmit);
            INTERCEPT(vkCreateFramebuffer);
            INTERCEPT(vkCreateRenderPass);
            INTERCEPT(vkCmdBeginRenderPass);
            INTERCEPT(vkCmdPipelineBarrier);
            #undef INTERCEPT
            #undef ALWAYS_INTERCEPT
            return fn;
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
        VkDevice                     device,
        const VkCommandBufferAllocateInfo*    pAllocateInfo,
        VkCommandBuffer          *pCommandBuffers) {
            PFN_vkAllocateCommandBuffers next =
            GetGlobalContext().GetVkDeviceData(device)->allocate_command_buffers;
            uint32_t nBuffers = pAllocateInfo->commandBufferCount;
            VkResult res = (VkResult) next(device, pAllocateInfo, pCommandBuffers);
            if (res != VK_SUCCESS) {
                return res;
            }
            {
                auto deviceFunctions = GetGlobalContext().GetVkDeviceData(device)->functions;
                auto commandBuffers = GetGlobalContext().GetVkCommandBufferMap();
                for (size_t i = 0; i < nBuffers; ++i) {
                    CommandBufferData dat;
                    dat.functions = deviceFunctions;
                    dat.device = device;
                    dat.command_pool = pAllocateInfo->commandPool;
                    (*commandBuffers)[pCommandBuffers[i]] = dat;
                }
            }
            return res;
        }
        VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
        VkDevice                                    device,
        uint32_t                                    queueFamilyIndex,
        uint32_t                                    queueIndex,
        VkQueue*                                    pQueue) {
            PFN_vkGetDeviceQueue next =
            GetGlobalContext().GetVkDeviceData(device)->get_device_queue;
            next(device, queueFamilyIndex, queueIndex, pQueue);
            {
                auto deviceFunctions = GetGlobalContext().GetVkDeviceData(device)->functions;
                auto queues = GetGlobalContext().GetVkQueueMap();
                QueueData dat;
                dat.functions = deviceFunctions;
                dat.device = device;
                (*queues)[*pQueue] = dat;
            }
        }
        void DestroyCommandBuffers(size_t count, const VkCommandBuffer* commandbuffers) {
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for (size_t i = 0; i < count; ++i) {
                    commandBufferMap->erase(commandbuffers[count]);
                }
            }
        }
        void DestroyQueue(VkQueue queue) {
            {
                auto queueMap = GetGlobalContext().GetVkQueueMap();
                queueMap->erase(queue);
            }
        }
        void DestroyDevice(VkDevice device) {
            std::vector<VkQueue> queues;
            std::vector<VkCommandBuffer> commandBuffers;
            {
                auto queueMap = GetGlobalContext().GetVkQueueMap();
                for(auto it: (*queueMap)) {
                    if(it.second.device == device) {
                        queues.push_back(it.first);
                    }
                }
            }
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for(auto it: (*commandBufferMap)) {
                    if(it.second.device == device) {
                        commandBuffers.push_back(it.first);
                    }
                }
            }
            for (auto queue: queues) {
                DestroyQueue(queue);
            }
            DestroyCommandBuffers(commandBuffers.size(), commandBuffers.data());
            for (auto queue: queues) {
                DestroyQueue(queue);
            }
            {
                delete GetGlobalContext().GetVkDeviceData(device)->functions;
            }
            {
                auto deviceMap = GetGlobalContext().GetVkDeviceMap();
                deviceMap->erase(device);
            }
        }
        void DestroyCommandPool(VkDevice device, VkCommandPool pool) {
            std::vector<VkCommandBuffer> commandBuffers;
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for(auto it: (*commandBufferMap)) {
                    if(it.second.device == device && it.second.command_pool == pool) {
                        commandBuffers.push_back(it.first);
                    }
                }
            }
            DestroyCommandBuffers(commandBuffers.size(), commandBuffers.data());
        }
        void DestroyInstance(VkInstance instance) {
            std::vector<VkDevice> devices;
            std::vector<VkPhysicalDevice> physical_devices;
            {
                auto deviceMap = GetGlobalContext().GetVkDeviceMap();
                for(auto it: (*deviceMap)) {
                    if(it.second.instance == instance) {
                        devices.push_back(it.first);
                    }
                }
            }
            for(auto dev: devices) {
                DestroyDevice(dev);
            }
            {
                std::vector<VkPhysicalDevice> physicalDevices;
                auto physicalDeviceMap  = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (auto it: *physicalDeviceMap) {
                    if (it.second.instance == instance) {
                        physicalDevices.push_back(it.first);
                    }
                }
                for (auto it: physicalDevices) {
                    physicalDeviceMap->erase(it);
                }
            }
            {
                delete GetGlobalContext().GetVkInstanceData(instance)->functions;
            }
            {
                auto instanceMap = GetGlobalContext().GetVkInstanceMap();
                instanceMap->erase(instance);
            }
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, AllocationCallbacks pAllocator) {
            PFN_vkDestroyCommandPool next =
            GetGlobalContext().GetVkDeviceData(device)->destroy_command_pool;
            next(device, commandPool, pAllocator);
            DestroyCommandPool(device, commandPool);
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(VkDevice device, AllocationCallbacks pAllocator) {
            PFN_vkDestroyDevice next =
            GetGlobalContext().GetVkDeviceData(device)->destroy_device;
            next(device, pAllocator);
            DestroyDevice(device);
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(VkInstance instance, AllocationCallbacks pAllocator) {
            PFN_vkDestroyInstance next =
            GetGlobalContext().GetVkInstanceData(instance)->destroy_instance;
            next(instance, pAllocator);
            DestroyInstance(instance);
        }
        VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        uint32_t                                    commandBufferCount,
        const VkCommandBuffer*                      pCommandBuffers) {
            PFN_vkFreeCommandBuffers next =
            GetGlobalContext().GetVkDeviceData(device)->free_command_buffers;
            next(device, commandPool, commandBufferCount, pCommandBuffers);
            DestroyCommandBuffers(commandBufferCount, pCommandBuffers);
        }
        // Overload GetDeviceProcAddr.
        // We provide an overload of vkDestroyDevice for book-keeping.
        // The rest of the overloads are swapchain-specific.
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
        vkGetDeviceProcAddr(VkDevice device, const char *pName) {
            if (strcmp(pName, "vkAllocateCommandBuffers") == 0) {
                return (PFN_vkVoidFunction)internal::vkAllocateCommandBuffers;
            }
            if (strcmp(pName, "vkGetDeviceQueue") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceQueue;
            }
            if (strcmp(pName, "vkDestroyCommandPool") == 0) {
                return (PFN_vkVoidFunction)internal::vkDestroyCommandPool;
            }
            if (strcmp(pName, "vkDestroyDevice") == 0) {
                return (PFN_vkVoidFunction)internal::vkDestroyDevice;
            }
            if (strcmp(pName, "vkFreeCommandBuffers") == 0) {
                return (PFN_vkVoidFunction)internal::vkFreeCommandBuffers;
            }
            if (strcmp(pName, "vkEnumerateDeviceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)internal::vkEnumerateDeviceExtensionProperties;
            }
            if (strcmp(pName, "vkGetDeviceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceProcAddr;
            }
            PFN_vkGetDeviceProcAddr device_proc_addr =
            GetGlobalContext().GetVkDeviceData(device)->get_device_proc_addr;
            auto fn = device_proc_addr(device, pName);
            #define INTERCEPT(func)         \
            if ((strcmp(pName, #func) == 0) && fn) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_amber_scoop::wrapped::func);
            #define ALWAYS_INTERCEPT(func)         \
            if (strcmp(pName, #func) == 0) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_amber_scoop::wrapped::func);
            INTERCEPT(vkCreateBuffer);
            INTERCEPT(vkCreateCommandPool);
            INTERCEPT(vkCmdCopyBuffer);
            INTERCEPT(vkCmdCopyBufferToImage);
            INTERCEPT(vkCreateDescriptorSetLayout);
            INTERCEPT(vkAllocateDescriptorSets);
            INTERCEPT(vkUpdateDescriptorSets);
            INTERCEPT(vkCmdBindDescriptorSets);
            INTERCEPT(vkCmdPushConstants);
            INTERCEPT(vkCmdBindIndexBuffer);
            INTERCEPT(vkCmdBindVertexBuffers);
            INTERCEPT(vkCmdDraw);
            INTERCEPT(vkCmdDrawIndexed);
            INTERCEPT(vkCreateImage);
            INTERCEPT(vkCreateSampler);
            INTERCEPT(vkCreatePipelineLayout);
            INTERCEPT(vkCreateGraphicsPipelines);
            INTERCEPT(vkCreateShaderModule);
            INTERCEPT(vkCmdBindPipeline);
            INTERCEPT(vkQueueSubmit);
            INTERCEPT(vkCreateFramebuffer);
            INTERCEPT(vkCreateRenderPass);
            INTERCEPT(vkCmdBeginRenderPass);
            INTERCEPT(vkCmdPipelineBarrier);
            #undef INTERCEPT
            #undef ALWAYS_INTERCEPT
            return fn;
        }
    }
}
extern "C" {
    #define LAYER_NAME "VK_LAYER_GRAPHICSFUZZ_amber_scoop"
    #define LAYER_NAME_FUNCTION(fn) VK_LAYER_GRAPHICSFUZZ_amber_scoop##fn
    // For this to function on Android the entry-point names for GetDeviceProcAddr
    // and GetInstanceProcAddr must be ${layer_name}/Get*ProcAddr.
    // This is a bit surprising given that we *MUST* also export
    // vkEnumerate*Layers without any prefix.
    VK_LAYER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
    LAYER_NAME_FUNCTION(GetDeviceProcAddr)(VkDevice dev, const char *funcName) {
        return graphicsfuzz_amber_scoop::internal::vkGetDeviceProcAddr(dev, funcName);
    }
    VK_LAYER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL LAYER_NAME_FUNCTION(
    GetInstanceProcAddr)(VkInstance instance, const char *funcName) {
        return graphicsfuzz_amber_scoop::internal::vkGetInstanceProcAddr(instance, funcName);
    }
    // Documentation is sparse for Android, looking at libvulkan.so
    // These 4 functions must be defined in order for this to even
    // be considered for loading.
    #if defined(__ANDROID__)
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount,
    VkLayerProperties *pProperties) {
        return graphicsfuzz_amber_scoop::internal::vkEnumerateInstanceLayerProperties(pPropertyCount,
        pProperties);
    }
    // On Android this must also be defined, even if we have 0
    // layers to expose.
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateInstanceExtensionProperties(const char *pLayerName,
    uint32_t *pPropertyCount,
    VkExtensionProperties *pProperties) {
        return graphicsfuzz_amber_scoop::internal::vkEnumerateInstanceExtensionProperties(
        pLayerName, pPropertyCount, pProperties);
    }
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount,
    VkLayerProperties *pProperties) {
        return graphicsfuzz_amber_scoop::internal::vkEnumerateDeviceLayerProperties(
        physicalDevice, pPropertyCount, pProperties);
    }
    // On Android this must also be defined, even if we have 0
    // layers to expose.
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice,
    const char *pLayerName,
    uint32_t *pPropertyCount,
    VkExtensionProperties *pProperties) {
        return graphicsfuzz_amber_scoop::internal::vkEnumerateDeviceExtensionProperties(
        physicalDevice, pLayerName, pPropertyCount, pProperties);
    }
    #endif
}