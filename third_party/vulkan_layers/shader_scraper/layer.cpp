/*
 * Copyright (C) 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include <vulkan/vk_layer.h>
#include <cstring>
#include "layer.h"
namespace graphicsfuzz_shader_scraper {
    Context &GetGlobalContext() {
        static Context kContext;
        return kContext;
    }
    namespace wrapped {
        VKAPI_ATTR uint32_t VKAPI_CALL vkCreateShaderModule(VkDevice device, VkShaderModuleCreateInfo const* pCreateInfo, AllocationCallbacks pAllocator, VkShaderModule* pShaderModule) {
            PFN_vkCreateShaderModule fn = GetGlobalContext().GetVkDeviceData(device)->functions->vkCreateShaderModule;
            return graphicsfuzz_shader_scraper::vkCreateShaderModule(fn, device, pCreateInfo, pAllocator, pShaderModule);
        }
    }
    namespace internal {
        namespace {
            template <typename T>
            struct link_info_traits {
                const static bool is_instance =
                std::is_same<T, const VkInstanceCreateInfo>::value;
                using layer_info_type =
                typename std::conditional<is_instance, VkLayerInstanceCreateInfo,
                VkLayerDeviceCreateInfo>::type;
                const static VkStructureType sType =
                is_instance ? VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO
                : VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
            };
            // Get layer_specific data for this layer.
            // Will return either VkLayerInstanceCreateInfo or
            // VkLayerDeviceCreateInfo depending on the type of the pCreateInfo
            // passed in.
            template <typename T>
            typename link_info_traits<T>::layer_info_type *get_layer_link_info(
            T *pCreateInfo) {
                using layer_info_type = typename link_info_traits<T>::layer_info_type;
                auto layer_info = const_cast<layer_info_type *>(
                static_cast<const layer_info_type *>(pCreateInfo->pNext));
                while (layer_info) {
                    if (layer_info->sType == link_info_traits<T>::sType &&
                    layer_info->function == VK_LAYER_LINK_INFO) {
                        return layer_info;
                    }
                    layer_info = const_cast<layer_info_type *>(
                    static_cast<const layer_info_type *>(layer_info->pNext));
                }
                return layer_info;
            }
        }
        static const VkLayerProperties global_layer_properties[] = { {
                "VK_LAYER_GRAPHICSFUZZ_shader_scraper",
                VK_VERSION_MAJOR(1) | VK_VERSION_MINOR(0) | 5,
                1,
                "",
            } };
        VKAPI_ATTR VkResult VKAPI_CALL get_layer_properties(uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            if (pProperties == NULL) {
                *pPropertyCount = 1;
                return VK_SUCCESS;
            }
            if (pPropertyCount == 0) {
                return VK_INCOMPLETE;
            }
            *pPropertyCount = 1;
            memcpy(pProperties, global_layer_properties, sizeof(global_layer_properties));
            return VK_SUCCESS;
        }
        VKAPI_ATTR VkResult VKAPI_CALL physical_device_layer_properties(
        VkPhysicalDevice,
        uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            return get_layer_properties(pPropertyCount, pProperties);
        }
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            PFN_vkEnumerateInstanceLayerProperties next = &get_layer_properties;
            return (VkResult) next(pPropertyCount, pProperties);
        }
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateDeviceLayerProperties(VkPhysicalDevice device, uint32_t *pPropertyCount,
        VkLayerProperties *pProperties) {
            PFN_vkEnumerateDeviceLayerProperties next = &physical_device_layer_properties;
            return (VkResult) next(device, pPropertyCount, pProperties);
        }
        // Overload vkEnumerateInstanceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        enumerate_instance_layer_properties(
        const char *, uint32_t * pPropertyCount,
        VkExtensionProperties *) {
            *pPropertyCount = 0;
            return VK_SUCCESS;
        }
        // Overload vkEnumerateInstanceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateInstanceExtensionProperties(
        const char * pLayerName, uint32_t *pPropertyCount,
        VkExtensionProperties * pProperties) {
            PFN_vkEnumerateInstanceExtensionProperties next = &enumerate_instance_layer_properties;
            return next(pLayerName, pPropertyCount, pProperties);
        }
        // Overload vkEnumerateDeviceExtensionProperties
        VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
        vkEnumerateDeviceExtensionProperties(
        VkPhysicalDevice device,
        const char * pLayerName, uint32_t *pPropertyCount,
        VkExtensionProperties * pProperties) {
            if (!device) { return VK_SUCCESS; }
            auto instance = GetGlobalContext().GetVkPhysicalDeviceData(device)->instance;
            PFN_vkEnumerateDeviceExtensionProperties next = GetGlobalContext().GetVkInstanceData(instance)->enumerate_device_extension_properties;
            return next(device, pLayerName, pPropertyCount, pProperties);
            *pPropertyCount = 0;
            return VK_SUCCESS;
        }
        // Overload vkCreateInstance. It is all book-keeping
        // and passthrough to the next layer (or ICD) in the chain.
        VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
        const VkInstanceCreateInfo *pCreateInfo,
        const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) {
            VkLayerInstanceCreateInfo *layer_info = get_layer_link_info(pCreateInfo);
            // Grab the pointer to the next vkGetInstanceProcAddr in the chain.
            PFN_vkGetInstanceProcAddr get_instance_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetInstanceProcAddr;
            // From that get the next vkCreateInstance function.
            PFN_vkCreateInstance create_instance = reinterpret_cast<PFN_vkCreateInstance>(
            get_instance_proc_addr(NULL, "vkCreateInstance"));
            if (create_instance == NULL) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            // The next layer may read from layer_info,
            // so advance the pointer for it.
            layer_info->u.pLayerInfo = layer_info->u.pLayerInfo->pNext;
            VkResult result = create_instance(pCreateInfo, pAllocator, pInstance);
            // If it failed, then we don't need to track this instance.
            if (result != VK_SUCCESS) return result;
            PFN_vkEnumeratePhysicalDevices enumerate_physical_devices =
            reinterpret_cast<PFN_vkEnumeratePhysicalDevices>(
            get_instance_proc_addr(*pInstance, "vkEnumeratePhysicalDevices"));
            if (!enumerate_physical_devices) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            PFN_vkEnumerateDeviceExtensionProperties
            enumerate_device_extension_properties =
            reinterpret_cast<PFN_vkEnumerateDeviceExtensionProperties>(
            get_instance_proc_addr(*pInstance,
            "vkEnumerateDeviceExtensionProperties"));
            if (!enumerate_device_extension_properties) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            InstanceData data;
            data.get_instance_proc_addr = get_instance_proc_addr;
            data.enumerate_physical_devices = enumerate_physical_devices;
            data.create_device = reinterpret_cast<PFN_vkCreateDevice>(
            get_instance_proc_addr(*pInstance, "vkCreateDevice"));
            data.destroy_instance = reinterpret_cast<PFN_vkDestroyInstance>(
            get_instance_proc_addr(*pInstance, "vkDestroyInstance"));
            data.enumerate_device_extension_properties = enumerate_device_extension_properties;
            data.functions = new InstanceFunctions();
            #define GET_PROC(name) \
            data.functions->name =          \
            reinterpret_cast<PFN_##name>(get_instance_proc_addr(*pInstance, #name))
            // Overrides
            // Called Functions
            #undef GET_PROC
            // Add this instance, along with the vkGetInstanceProcAddr to our
            // map. This way when someone calls vkGetInstanceProcAddr, we can forward
            // it to the correct "next" vkGetInstanceProcAddr.
            {
                auto instances = GetGlobalContext().GetVkInstanceMap();
                // The same instance was returned twice, this is a problem.
                if (instances->find(*pInstance) != instances->end()) {
                    return VK_ERROR_INITIALIZATION_FAILED;
                }
                (*instances)[*pInstance] = data;
            }
            {
                auto instance = *pInstance;
                std::vector<VkPhysicalDevice> devices;
                uint32_t device_count = 0;
                enumerate_physical_devices(*pInstance, &device_count, nullptr);
                devices.resize(device_count);
                enumerate_physical_devices(*pInstance, &device_count, devices.data());
                auto instanceFunctions = GetGlobalContext().GetVkInstanceData(instance)->functions;
                auto create_device = GetGlobalContext().GetVkInstanceData(instance)->create_device;
                auto physicalDevices = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (size_t i = 0; i < device_count; ++i) {
                    PhysicalDeviceData dat;
                    dat.create_device = create_device;
                    dat.functions = instanceFunctions;
                    dat.instance = instance;
                    if (physicalDevices->find(devices[i]) != physicalDevices->end()) {
                        continue;
                    }
                    (*physicalDevices)[devices[i]] = dat;
                }
            }
            return result;
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
        VkInstance        instance,
        uint32_t*         pPhysicalDeviceCount,
        VkPhysicalDevice* pPhysicalDevices) {
            PFN_vkEnumeratePhysicalDevices next =
            GetGlobalContext().GetVkInstanceData(instance)->enumerate_physical_devices;
            VkResult res = (VkResult) next(instance, pPhysicalDeviceCount, pPhysicalDevices);
            if (pPhysicalDevices == nullptr) {
                return res;
            }
            if (res != VK_SUCCESS && res != VK_INCOMPLETE) {
                return res;
            }
            {
                auto instanceFunctions = GetGlobalContext().GetVkInstanceData(instance)->functions;
                auto create_device = GetGlobalContext().GetVkInstanceData(instance)->create_device;
                auto physicalDevices = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (size_t i = 0; i < *pPhysicalDeviceCount; ++i) {
                    PhysicalDeviceData dat;
                    dat.create_device = create_device;
                    dat.functions = instanceFunctions;
                    dat.instance = instance;
                    if (physicalDevices->find(pPhysicalDevices[i]) != physicalDevices->end()) {
                        continue;
                    }
                    (*physicalDevices)[pPhysicalDevices[i]] = dat;
                }
            }
            return res;
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
        VkPhysicalDevice             physicalDevice,
        const VkDeviceCreateInfo*    pCreateInfo,
        AllocationCallbacks          pAllocator,
        VkDevice*                    pDevice) {
            VkLayerDeviceCreateInfo *layer_info = get_layer_link_info(pCreateInfo);
            // Grab the fpGetInstanceProcAddr from the layer_info. We will get
            // vkCreateDevice from this.
            // Note: we cannot use our instance_map because we do not have a
            // vkInstance here.
            PFN_vkGetInstanceProcAddr get_instance_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetInstanceProcAddr;
            PFN_vkCreateDevice next = reinterpret_cast<PFN_vkCreateDevice>(
            get_instance_proc_addr(NULL, "vkCreateDevice"));
            if (!next) {
                return VK_ERROR_INITIALIZATION_FAILED;
            }
            // We want to store off the next vkGetDeviceProcAddr so keep track of it now
            // before we advance the pointer.
            PFN_vkGetDeviceProcAddr get_device_proc_addr =
            layer_info->u.pLayerInfo->pfnNextGetDeviceProcAddr;
            // The next layer may read from layer_info,
            // so advance the pointer for it.
            layer_info->u.pLayerInfo = layer_info->u.pLayerInfo->pNext;
            VkResult res = (VkResult) next(physicalDevice, pCreateInfo, pAllocator, pDevice);
            if (res != VK_SUCCESS) {
                return res;
            }
            DeviceData data;
            data.functions = new DeviceFunctions();
            data.physical_device = physicalDevice;
            data.instance = GetGlobalContext().GetVkPhysicalDeviceData(physicalDevice)->instance;
            data.get_device_proc_addr = get_device_proc_addr;
            data.allocate_command_buffers = reinterpret_cast<PFN_vkAllocateCommandBuffers>(get_device_proc_addr(*pDevice, "vkAllocateCommandBuffers"));
            data.get_device_queue = reinterpret_cast<PFN_vkGetDeviceQueue>(get_device_proc_addr(*pDevice, "vkGetDeviceQueue"));
            data.destroy_device = reinterpret_cast<PFN_vkDestroyDevice>(get_device_proc_addr(*pDevice, "vkDestroyDevice"));
            data.free_command_buffers = reinterpret_cast<PFN_vkFreeCommandBuffers>(get_device_proc_addr(*pDevice, "vkFreeCommandBuffers"));
            data.destroy_command_pool = reinterpret_cast<PFN_vkDestroyCommandPool>(get_device_proc_addr(*pDevice, "vkDestroyCommandPool"));
            #define GET_PROC(name) \
            data.functions->name =          \
            reinterpret_cast<PFN_##name>(get_device_proc_addr(*pDevice, #name))
            // Overrides
            GET_PROC(vkCreateShaderModule);
            // Called Functions
            #undef GET_PROC
            {
                auto devices = GetGlobalContext().GetVkDeviceMap();
                (*devices)[*pDevice] = data;
            }
            return res;
        }
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
        vkGetDeviceProcAddr(VkDevice device, const char *pName);
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
        const VkInstance  instance,
        const char* pName) {
            if (strcmp(pName, "vkCreateInstance") == 0) {
                return (PFN_vkVoidFunction)(internal::vkCreateInstance);
            }
            if (strcmp(pName, "vkEnumerateInstanceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)(internal::vkEnumerateInstanceExtensionProperties);
            }
            if (strcmp(pName, "vkEnumerateInstanceLayerProperties") == 0 ) {
                return (PFN_vkVoidFunction)(internal::vkEnumerateInstanceLayerProperties);
            }
            if (strcmp(pName, "vkEnumerateDeviceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)internal::vkEnumerateDeviceExtensionProperties;
            }
            if (strcmp(pName, "vkGetInstanceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetInstanceProcAddr;
            }
            if (strcmp(pName, "vkGetDeviceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceProcAddr;
            }
            if (instance == 0) {
                return nullptr;
            }
            if (strcmp(pName, "vkEnumeratePhysicalDevices") == 0) {
                return (PFN_vkVoidFunction)(internal::vkEnumeratePhysicalDevices);
            }
            if (strcmp(pName, "vkCreateDevice") == 0) {
                return (PFN_vkVoidFunction)(internal::vkCreateDevice);
            }
            #define INTERCEPT(func)         \
            if (strcmp(pName, #func) == 0) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_shader_scraper::wrapped::func);
            INTERCEPT(vkCreateShaderModule);
            #undef INTERCEPT
            PFN_vkGetInstanceProcAddr instance_proc_addr =
            GetGlobalContext().GetVkInstanceData(instance)->get_instance_proc_addr;
            return instance_proc_addr(instance, pName);
        }
        VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
        VkDevice                     device,
        const VkCommandBufferAllocateInfo*    pAllocateInfo,
        VkCommandBuffer          *pCommandBuffers) {
            PFN_vkAllocateCommandBuffers next =
            GetGlobalContext().GetVkDeviceData(device)->allocate_command_buffers;
            uint32_t nBuffers = pAllocateInfo->commandBufferCount;
            VkResult res = (VkResult) next(device, pAllocateInfo, pCommandBuffers);
            if (res != VK_SUCCESS) {
                return res;
            }
            {
                auto deviceFunctions = GetGlobalContext().GetVkDeviceData(device)->functions;
                auto commandBuffers = GetGlobalContext().GetVkCommandBufferMap();
                for (size_t i = 0; i < nBuffers; ++i) {
                    CommandBufferData dat;
                    dat.functions = deviceFunctions;
                    dat.device = device;
                    dat.command_pool = pAllocateInfo->commandPool;
                    (*commandBuffers)[pCommandBuffers[i]] = dat;
                }
            }
            return res;
        }
        VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
        VkDevice                                    device,
        uint32_t                                    queueFamilyIndex,
        uint32_t                                    queueIndex,
        VkQueue*                                    pQueue) {
            PFN_vkGetDeviceQueue next =
            GetGlobalContext().GetVkDeviceData(device)->get_device_queue;
            next(device, queueFamilyIndex, queueIndex, pQueue);
            {
                auto deviceFunctions = GetGlobalContext().GetVkDeviceData(device)->functions;
                auto queues = GetGlobalContext().GetVkQueueMap();
                QueueData dat;
                dat.functions = deviceFunctions;
                dat.device = device;
                (*queues)[*pQueue] = dat;
            }
        }
        void DestroyCommandBuffers(size_t count, const VkCommandBuffer* commandbuffers) {
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for (size_t i = 0; i < count; ++i) {
                    commandBufferMap->erase(commandbuffers[count]);
                }
            }
        }
        void DestroyQueue(VkQueue queue) {
            {
                auto queueMap = GetGlobalContext().GetVkQueueMap();
                queueMap->erase(queue);
            }
        }
        void DestroyDevice(VkDevice device) {
            std::vector<VkQueue> queues;
            std::vector<VkCommandBuffer> commandBuffers;
            {
                auto queueMap = GetGlobalContext().GetVkQueueMap();
                for(auto it: (*queueMap)) {
                    if(it.second.device == device) {
                        queues.push_back(it.first);
                    }
                }
            }
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for(auto it: (*commandBufferMap)) {
                    if(it.second.device == device) {
                        commandBuffers.push_back(it.first);
                    }
                }
            }
            for (auto queue: queues) {
                DestroyQueue(queue);
            }
            DestroyCommandBuffers(commandBuffers.size(), commandBuffers.data());
            for (auto queue: queues) {
                DestroyQueue(queue);
            }
            {
                delete GetGlobalContext().GetVkDeviceData(device)->functions;
            }
            {
                auto deviceMap = GetGlobalContext().GetVkDeviceMap();
                deviceMap->erase(device);
            }
        }
        void DestroyCommandPool(VkDevice device, VkCommandPool pool) {
            std::vector<VkCommandBuffer> commandBuffers;
            {
                auto commandBufferMap = GetGlobalContext().GetVkCommandBufferMap();
                for(auto it: (*commandBufferMap)) {
                    if(it.second.device == device && it.second.command_pool == pool) {
                        commandBuffers.push_back(it.first);
                    }
                }
            }
            DestroyCommandBuffers(commandBuffers.size(), commandBuffers.data());
        }
        void DestroyInstance(VkInstance instance) {
            std::vector<VkDevice> devices;
            std::vector<VkPhysicalDevice> physical_devices;
            {
                auto deviceMap = GetGlobalContext().GetVkDeviceMap();
                for(auto it: (*deviceMap)) {
                    if(it.second.instance == instance) {
                        devices.push_back(it.first);
                    }
                }
            }
            for(auto dev: devices) {
                DestroyDevice(dev);
            }
            {
                std::vector<VkPhysicalDevice> physicalDevices;
                auto physicalDeviceMap  = GetGlobalContext().GetVkPhysicalDeviceMap();
                for (auto it: *physicalDeviceMap) {
                    if (it.second.instance == instance) {
                        physicalDevices.push_back(it.first);
                    }
                }
                for (auto it: physicalDevices) {
                    physicalDeviceMap->erase(it);
                }
            }
            {
                delete GetGlobalContext().GetVkInstanceData(instance)->functions;
            }
            {
                auto instanceMap = GetGlobalContext().GetVkInstanceMap();
                instanceMap->erase(instance);
            }
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, AllocationCallbacks pAllocator) {
            PFN_vkDestroyCommandPool next =
            GetGlobalContext().GetVkDeviceData(device)->destroy_command_pool;
            next(device, commandPool, pAllocator);
            DestroyCommandPool(device, commandPool);
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(VkDevice device, AllocationCallbacks pAllocator) {
            PFN_vkDestroyDevice next =
            GetGlobalContext().GetVkDeviceData(device)->destroy_device;
            next(device, pAllocator);
            DestroyDevice(device);
        }
        VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(VkInstance instance, AllocationCallbacks pAllocator) {
            PFN_vkDestroyInstance next =
            GetGlobalContext().GetVkInstanceData(instance)->destroy_instance;
            next(instance, pAllocator);
            DestroyInstance(instance);
        }
        VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        uint32_t                                    commandBufferCount,
        const VkCommandBuffer*                      pCommandBuffers) {
            PFN_vkFreeCommandBuffers next =
            GetGlobalContext().GetVkDeviceData(device)->free_command_buffers;
            next(device, commandPool, commandBufferCount, pCommandBuffers);
            DestroyCommandBuffers(commandBufferCount, pCommandBuffers);
        }
        // Overload GetDeviceProcAddr.
        // We provide an overload of vkDestroyDevice for book-keeping.
        // The rest of the overloads are swapchain-specific.
        VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
        vkGetDeviceProcAddr(VkDevice device, const char *pName) {
            if (strcmp(pName, "vkAllocateCommandBuffers") == 0) {
                return (PFN_vkVoidFunction)internal::vkAllocateCommandBuffers;
            }
            if (strcmp(pName, "vkGetDeviceQueue") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceQueue;
            }
            if (strcmp(pName, "vkDestroyCommandPool") == 0) {
                return (PFN_vkVoidFunction)internal::vkDestroyCommandPool;
            }
            if (strcmp(pName, "vkDestroyDevice") == 0) {
                return (PFN_vkVoidFunction)internal::vkDestroyDevice;
            }
            if (strcmp(pName, "vkFreeCommandBuffers") == 0) {
                return (PFN_vkVoidFunction)internal::vkFreeCommandBuffers;
            }
            if (strcmp(pName, "vkEnumerateDeviceExtensionProperties") == 0) {
                return (PFN_vkVoidFunction)internal::vkEnumerateDeviceExtensionProperties;
            }
            if (strcmp(pName, "vkGetDeviceProcAddr") == 0) {
                return (PFN_vkVoidFunction)internal::vkGetDeviceProcAddr;
            }
            #define INTERCEPT(func)         \
            if (strcmp(pName, #func) == 0) \
            return reinterpret_cast<PFN_vkVoidFunction>(graphicsfuzz_shader_scraper::wrapped::func);
            INTERCEPT(vkCreateShaderModule);
            #undef INTERCEPT
            PFN_vkGetDeviceProcAddr device_proc_addr =
            GetGlobalContext().GetVkDeviceData(device)->get_device_proc_addr;
            return device_proc_addr(device, pName);
        }
    }
}
extern "C" {
    #define LAYER_NAME "VK_LAYER_GRAPHICSFUZZ_shader_scraper"
    #define LAYER_NAME_FUNCTION(fn) VK_LAYER_GRAPHICSFUZZ_shader_scraper##fn
    // For this to function on Android the entry-point names for GetDeviceProcAddr
    // and GetInstanceProcAddr must be ${layer_name}/Get*ProcAddr.
    // This is a bit surprising given that we *MUST* also export
    // vkEnumerate*Layers without any prefix.
    VK_LAYER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
    LAYER_NAME_FUNCTION(GetDeviceProcAddr)(VkDevice dev, const char *funcName) {
        return graphicsfuzz_shader_scraper::internal::vkGetDeviceProcAddr(dev, funcName);
    }
    VK_LAYER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL LAYER_NAME_FUNCTION(
    GetInstanceProcAddr)(VkInstance instance, const char *funcName) {
        return graphicsfuzz_shader_scraper::internal::vkGetInstanceProcAddr(instance, funcName);
    }
    // Documentation is sparse for Android, looking at libvulkan.so
    // These 4 functions must be defined in order for this to even
    // be considered for loading.
    #if defined(__ANDROID__)
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount,
    VkLayerProperties *pProperties) {
        return graphicsfuzz_shader_scraper::internal::vkEnumerateInstanceLayerProperties(pPropertyCount,
        pProperties);
    }
    // On Android this must also be defined, even if we have 0
    // layers to expose.
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateInstanceExtensionProperties(const char *pLayerName,
    uint32_t *pPropertyCount,
    VkExtensionProperties *pProperties) {
        return graphicsfuzz_shader_scraper::internal::vkEnumerateInstanceExtensionProperties(
        pLayerName, pPropertyCount, pProperties);
    }
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount,
    VkLayerProperties *pProperties) {
        return graphicsfuzz_shader_scraper::internal::vkEnumerateDeviceLayerProperties(
        physicalDevice, pPropertyCount, pProperties);
    }
    // On Android this must also be defined, even if we have 0
    // layers to expose.
    VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
    vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice,
    const char *pLayerName,
    uint32_t *pPropertyCount,
    VkExtensionProperties *pProperties) {
        return graphicsfuzz_shader_scraper::internal::vkEnumerateDeviceExtensionProperties(
        physicalDevice, pLayerName, pPropertyCount, pProperties);
    }
    #endif
}