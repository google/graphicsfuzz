/*
 * Copyright 2019 The GraphicsFuzz Project Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.graphicsfuzz.generator.knownvaluegeneration;

import com.graphicsfuzz.common.ast.TranslationUnit;
import com.graphicsfuzz.common.ast.decl.Declaration;
import com.graphicsfuzz.common.ast.decl.FunctionDefinition;
import com.graphicsfuzz.common.ast.decl.FunctionPrototype;
import com.graphicsfuzz.common.ast.decl.Initializer;
import com.graphicsfuzz.common.ast.decl.ParameterDecl;
import com.graphicsfuzz.common.ast.decl.VariableDeclInfo;
import com.graphicsfuzz.common.ast.decl.VariablesDeclaration;
import com.graphicsfuzz.common.ast.expr.BinOp;
import com.graphicsfuzz.common.ast.expr.BinaryExpr;
import com.graphicsfuzz.common.ast.expr.Expr;
import com.graphicsfuzz.common.ast.expr.FunctionCallExpr;
import com.graphicsfuzz.common.ast.expr.UnOp;
import com.graphicsfuzz.common.ast.expr.UnaryExpr;
import com.graphicsfuzz.common.ast.expr.VariableIdentifierExpr;
import com.graphicsfuzz.common.ast.stmt.BlockStmt;
import com.graphicsfuzz.common.ast.stmt.DeclarationStmt;
import com.graphicsfuzz.common.ast.stmt.ExprStmt;
import com.graphicsfuzz.common.ast.stmt.ForStmt;
import com.graphicsfuzz.common.ast.stmt.NullStmt;
import com.graphicsfuzz.common.ast.stmt.ReturnStmt;
import com.graphicsfuzz.common.ast.stmt.Stmt;
import com.graphicsfuzz.common.ast.type.BasicType;
import com.graphicsfuzz.common.ast.type.Type;
import com.graphicsfuzz.common.ast.type.VoidType;
import com.graphicsfuzz.common.util.IRandom;
import com.graphicsfuzz.common.util.IdGenerator;
import com.graphicsfuzz.common.util.PipelineInfo;
import com.graphicsfuzz.generator.semanticschanging.LiteralFuzzer;
import com.graphicsfuzz.util.Constants;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class ExpressionGenerator {

  private static final int MAX_FUNCTION_PARAMS = 5;
  private static final int NUM_WAYS_TO_GENERATE_EXPR = 7;
  private static final int MAX_DEPTH = 5;
  // Theses boundaries are taken from the LiteralFuzzer, we may want to consider
  // modifying these values.
  private static final int INT_MIN = 0;
  private static final int INT_MAX = 1 << 17;

  private static final String NEGATIVE = "_negative";
  private static final String ID = "_id";

  private final TranslationUnit translationUnit;
  private final PipelineInfo pipelineInfo;
  private final IdGenerator idGenerator;
  private final IRandom generator;
  private int currentDepth;
  private final LiteralFuzzer literalFuzzer;
  private final FactManager globalFactManager;

  public ExpressionGenerator(TranslationUnit translationUnit, PipelineInfo pipelineInfo,
                             IRandom generator,
                             FactManager globalFactManager) {
    this.translationUnit = translationUnit;
    this.pipelineInfo = pipelineInfo;
    this.idGenerator = new IdGenerator();
    this.generator = generator;
    this.currentDepth = 0;
    this.literalFuzzer = new LiteralFuzzer(this.generator);
    this.globalFactManager = globalFactManager;
  }

  private Expr generateLiteralValue(Value value) {
    return value.generateLiteral(literalFuzzer);
  }

  /**
   * This function applies various transformations and returns a expression that guarantees to
   * compute the given value. If the value is unknown, fact manager would generate any
   * arbitrary values that have the correct type.
   *
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param functionDefinition a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @return the expression whose value is known by the fact manager.
   */
  public Expr generateExpr(FactManager factManager,
                           FunctionDefinition functionDefinition,
                           Stmt stmtToInsertBefore,
                           Value value) {
    if (currentDepth > MAX_DEPTH) {
      // When current depth has reached the maximum limit, we don't want generation to go deeper.
      // Thus, we consider generating a new expression from non-recursive approaches only.
      // To do so, we will choose to either generating the expression by making the literal
      // value or calling the already declared variables retrieved from the fact manager.
      Expr result;
      do {
        if (generator.nextBoolean()) {
          result = generateLiteralValue(value);
        } else {
          result = generateKnownVariableFact(value, factManager);
        }
      } while (result == null);
      return result;
    }

    currentDepth++;
    Expr result;

    while (true) {
      switch (generator.nextInt(NUM_WAYS_TO_GENERATE_EXPR)) {
        case 0:
          result = generateLiteralValue(value);
          break;
        case 1:
          result = generateVariableFact(value, factManager, functionDefinition, stmtToInsertBefore);
          break;
        case 2:
          result = generateKnownVariableFact(value, factManager);
          break;
        case 3:
          result = generateFunctionFact(value, factManager, functionDefinition, stmtToInsertBefore);
          break;
        case 4:
          result = generateKnownFunctionFact(factManager, value, functionDefinition,
              stmtToInsertBefore);
          break;
        case 5:
          result = generateAdditionValue(value, factManager, functionDefinition,
              stmtToInsertBefore);
          break;
        case 6:
          result = generateForLoopValue(value, factManager, functionDefinition, stmtToInsertBefore);
          break;
        default:
          throw new RuntimeException("Should be unreachable as switch cases cover all cases");
      }
      if (result != null) {
        break;
      }
    }
    currentDepth--;
    return result;
  }

  /**
   * Assigns value to the newly-generated variable using a for loop. To do so, we first pick a
   * random number (divisor) and add this number to the variable for each iteration. Then, we
   * basically find a number of iterations by dividing the original value by the chosen divisor
   * . We would also have to eventually add the remainder to the variable if needed.
   *
   * <p>For example, given a value x we can derive a for loop statement and a remainder from the
   * equation x = (divisor * iterations) + remainder.
   *
   * <p>The code fragment below is an example result obtained by this method which returns an int 7.
   * int _GLF_PRIMITIVE_int_7 = 0;
   * // 3 is the number of iterations obtained by dividing the given value 7 by the random
   * divisor 2.
   * for(int i = 0; i < 3; i ++) {
   * _GLF_PRIMITIVE_int_7 += 2;
   * }
   * _GLF_PRIMITIVE_int_7 += 1;     // 1 is a remainder of 7 divided by 2.
   *
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param currentFunction    a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @return a variable identifier to the new variable generated by this method.
   */
  private Expr generateForLoopValue(Value value,
                                    FactManager factManager,
                                    FunctionDefinition currentFunction,
                                    Stmt stmtToInsertBefore) {
    // TODO(https://github.com/google/graphicsfuzz/issues/661): we can also generate for loop
    //  value of UINT type.
    if (value.getType() != BasicType.INT) {
      return null;
    }
    // If the given fact manager is at global scope, the caller expects a expression generated by
    // this method to be available at the global scope. However the new for loop statement
    // generated by this method will be injected into the body of a given function making it
    // available only in the local scope. Hence, if the global scope expression is requested,
    // null is returned.
    if (factManager.globalScope()) {
      return null;
    }

    // Declare and initialize a zero-value variable.
    final String varName = genVarName(value, false);
    final VariableDeclInfo variableDeclInfo = new VariableDeclInfo(varName, null,
        new Initializer(
            generateExpr(factManager,
                currentFunction,
                stmtToInsertBefore,
                new NumericValue(BasicType.INT, Optional.of(0)))
        ));
    final VariablesDeclaration variablesDecl = new VariablesDeclaration(value.getType(),
        variableDeclInfo);
    currentFunction.getBody().insertBefore(stmtToInsertBefore,
        new DeclarationStmt(variablesDecl));

    // Decide whether the loop should be incremented or decremented for each iteration.
    final boolean isIncrement = generator.nextBoolean();
    // If value is unknown, we could generate and return any number.
    int original = (int) ((NumericValue) value).getValue().orElse(generator.nextInt(INT_MAX));

    // if the original value is zero, calling random wrapper will thrown an error illegal argument
    // exception.
    if (original < 1) {
      return null;
    }
    // A random number that will be added to the variable on each iteration.
    // We use max function here to prevent the division by zero error.
    int divisor = Math.max(1, generator.nextInt(original));

    // TODO(https://github.com/google/graphicsfuzz/issues/659): we should be able to set the max
    //  limit as we don't want to end up having a large number of iterations.
    final int iterations = original / divisor;
    // A left over number that will be added after for loop is executed. The binary
    // expression responsible to add a remainder to the variable will be inserted after for
    // loop statement.
    final int remainder = original % divisor;

    // Values of numbers which will be used for the for loop.
    final Value divisorValue = new NumericValue(BasicType.INT, Optional.of(divisor));
    final Value iterationValue = new NumericValue(BasicType.INT,
        Optional.of(isIncrement ? 0 : iterations));
    final Value conditionValue = new NumericValue(BasicType.INT,
        Optional.of(isIncrement ? iterations : 0));

    final Stmt init = new DeclarationStmt(new VariablesDeclaration(BasicType.INT,
        new VariableDeclInfo("i", null,
            new Initializer(generateExpr(factManager, currentFunction, stmtToInsertBefore,
                iterationValue))))
    );
    final Expr condition = new BinaryExpr(new VariableIdentifierExpr("i"),
        generateExpr(factManager, currentFunction, stmtToInsertBefore, conditionValue),
        isIncrement ? BinOp.LT : BinOp.GE);
    final Expr increment = new UnaryExpr(new VariableIdentifierExpr("i"),
        isIncrement ? UnOp.POST_INC : UnOp.POST_DEC);
    final Stmt body = new BlockStmt(Arrays.asList(new ExprStmt(new BinaryExpr(
        new VariableIdentifierExpr(varName),
        generateExpr(
            factManager,
            currentFunction,
            stmtToInsertBefore,
            divisorValue),
        BinOp.ADD_ASSIGN
    ))), false);
    final ForStmt forStmt = new ForStmt(init, condition, increment, body);
    currentFunction.getBody().insertBefore(stmtToInsertBefore, forStmt);

    if (remainder > 0) {
      final Value remainderValue = new NumericValue((BasicType) value.getType(),
          Optional.of(remainder));
      currentFunction.getBody().insertBefore(stmtToInsertBefore, new ExprStmt(new BinaryExpr(
          new VariableIdentifierExpr(varName),
          generateExpr(factManager, currentFunction, stmtToInsertBefore, remainderValue),
          BinOp.ADD_ASSIGN
      )));
    }
    final VariableDeclFact variableDeclFact = new VariableDeclFact(variablesDecl,
        variableDeclInfo, value);
    factManager.addVariableFact(value, variableDeclFact);
    return new VariableIdentifierExpr(varName);
  }

  // A utility method performing the subtraction of the interface Number.
  private Number subtractNumbers(Number firstOperand, Number secondOperand) {
    if (firstOperand instanceof Float) {
      assert secondOperand instanceof Float;
      return firstOperand.floatValue() - secondOperand.floatValue();
    }
    assert firstOperand instanceof Integer && secondOperand instanceof Integer;
    return firstOperand.intValue() - secondOperand.intValue();
  }

  /**
   * This method generates the expression that performs the addition of two values which result is
   * equal to the given value.
   *
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param currentFunction    a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @return a binary expression performing the addition of two numbers whose sum is equal to Value.
   */
  private Expr generateAdditionValue(Value value,
                                     FactManager factManager,
                                     FunctionDefinition currentFunction,
                                     Stmt stmtToInsertBefore) {
    if (!(value instanceof NumericValue)) {
      return null;
    }
    // TODO(https://github.com/google/graphicsfuzz/issues/661): we can also generate addition
    //  value of UINT type.
    if (value.getType() != BasicType.INT && value.getType() != BasicType.FLOAT) {
      return null;
    }
    // If the given value is unknown, we are free to choose any arbitrary numbers for addition.
    if (value.valueIsUnknown()) {
      return new BinaryExpr(
          generateExpr(factManager, currentFunction, stmtToInsertBefore,
              new NumericValue((BasicType) value.getType(), Optional.empty())),
          generateExpr(factManager, currentFunction, stmtToInsertBefore,
              new NumericValue((BasicType) value.getType(), Optional.empty())),
          BinOp.ADD);
    }

    Number summandA;
    // Given the expected type, we have to retrieve all values from the fact manager and filter only
    // the facts that are known to compute particular values.
    final List<Value> knownValues = factManager.getValuesFromType(value.getType())
        .stream().filter(item -> !item.valueIsUnknown()).collect(Collectors.toList());
    boolean genSummandsFromKnownValues = generator.nextBoolean();
    // If we are able to find any known values with the correct type, we then consider choosing
    // summands based on such values. Otherwise, we will have to pick a random number to make an
    // addition expression.
    if (!knownValues.isEmpty() && genSummandsFromKnownValues) {
      summandA = ((NumericValue) knownValues
          .get(generator.nextInt(knownValues.size())))
          .getValue().get();
    } else {
      if (value.getType() == BasicType.FLOAT) {
        // TODO(https://github.com/google/graphicsfuzz/issues/688): range of numbers [-10, 10] is
        //  temporarily used here, we have to change how the summand is generated.
        summandA = (float) generator.nextInt(21) - 10;
      } else {
        summandA = generator.nextInt(INT_MAX);
      }
    }

    final Number expected = ((NumericValue) value).getValue().get();
    // To get the second summand, we subtract original value by the the first summand.
    final Number summandB = subtractNumbers(expected, summandA);
    // Randomly decide whether summandA or summandB should be the first summand.
    final boolean summandAFirst = generator.nextBoolean();
    final Number firstSummand = summandAFirst ? summandA : summandB;
    final Number secondSummand = summandAFirst ? summandB : summandA;

    return new BinaryExpr(
        generateExpr(factManager, currentFunction, stmtToInsertBefore,
            new NumericValue((BasicType) value.getType(), Optional.of(firstSummand))),
        generateExpr(factManager, currentFunction, stmtToInsertBefore,
            new NumericValue((BasicType) value.getType(), Optional.of(secondSummand))),
        BinOp.ADD);
  }

  /**
   * Retrieves known value from the function facts hold by fact manager and returns the
   * function call to that function with the appropriate parameters if there is a function fact that
   * represents the given value.
   *
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param currentFunction    a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @return a function call expression to the already declared function representing the Value.
   */
  private Expr generateKnownFunctionFact(FactManager factManager,
                                         Value value,
                                         FunctionDefinition currentFunction,
                                         Stmt stmtToInsertBefore) {
    final List<FunctionFact> availableFacts = factManager.getFunctionFacts(value);
    if (availableFacts.isEmpty()) {
      return null;
    }
    final FunctionFact functionFact = availableFacts.get(generator.nextInt(availableFacts.size()));
    final List<Value> argValues = functionFact.getArguments();
    final List<Expr> args = generateArgsForFunctionCall(factManager, currentFunction,
        stmtToInsertBefore,
        argValues);
    return new FunctionCallExpr(functionFact.getFunctionName(), args);
  }

  /**
   * Retrieves known value from the variable facts hold by fact manager and returns the
   * variable identifier to that variable if there is a variable fact that represents the given
   * value.
   *
   * @param value       the value that will be computed by the expression generated by
   *                    this method.
   * @param factManager manager class holding the value and its associated expression that
   *                    guarantees to compute the given value.
   * @return a variable identifier expression to the already declared variable representing value.
   */
  private Expr generateKnownVariableFact(Value value, FactManager factManager) {
    final List<VariableFact> availableFacts = factManager.getVariableFacts(value);
    if (availableFacts.isEmpty()) {
      return null;
    }
    final VariableFact variableFact = availableFacts.get(generator.nextInt(availableFacts.size()));
    return new VariableIdentifierExpr(variableFact.getVariableName());
  }

  /**
   * Utility function to generate a set of expressions used as the arguments of the function call
   * expression.
   *
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param functionDefinition a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @param argValues          values of function arguments from which the new values being
   *                           generated are derived.
   * @return a list of function argument expressions.
   */
  private List<Expr> generateArgsForFunctionCall(FactManager factManager,
                                                 FunctionDefinition functionDefinition,
                                                 Stmt stmtToInsertBefore,
                                                 List<Value> argValues) {
    return argValues.stream()
        .map(item -> generateExpr(
            factManager,
            functionDefinition,
            stmtToInsertBefore,
            item
        )).collect(Collectors.toList());
  }

  private String freshId() {
    return ID + "_" + idGenerator.freshId();
  }

  private String genVarName(Value value, boolean isGlobal) {
    // Provides name for a new variable based on the given value.
    // For example:
    // _GLF_PRIMITIVE_int_negative_103_0_id_18: a variable of a value -103.
    // _GLF_PRIMITIVE_float_unknown_numeric_id_69: a variable that can be any value of float type.
    return (isGlobal ? Constants.GLF_PRIMITIVE_GLOBAL : Constants.GLF_PRIMITIVE)
        + "_" + value.getType().toString()
        + parseNameFromValue(value)
        + freshId();
  }

  private String genFunctionName(Value value) {
    // Provides name for a new function based on the given value.
    // For example:
    // _GLF_COMPUTE_float_1_0_id_0: a function that returns a value 1.0 of float type.
    // _GLF_COMPUTE_vec4_UNKNOWN_id_1: a function that returns randomly generated value of vec4
    // type.
    return Constants.GLF_COMPUTE
        + "_" + value.getType().toString()
        + parseNameFromValue(value)
        + freshId();
  }

  private String genParamName(Value value) {
    // Provides name for a function arguments based on the given value.
    // For example:
    //  _GLF_UNKNOWN_PARAM_vec4_id_1: a parameter of unknown value of vec4 type.
    //  _GLF_PARAM_int_id_62: a parameter of integer type.
    return (value.valueIsUnknown() ? Constants.GLF_UNKNOWN_PARAM : Constants.GLF_PARAM)
        + "_" + value.getType().toString()
        + parseNameFromValue(value)
        + freshId();
  }

  /**
   * Utility function to parse name from the given value, for example, -0.45 will be parsed as
   * negative_0_45.
   *
   * @param value value that will be converted to the name of variables or functions.
   * @return a string derived from the given value which will be used as function or variable names.
   */
  private String parseNameFromValue(Value value) {
    if (value.valueIsUnknown()) {
      return "_" + value.toString();
    }
    final StringBuilder name = new StringBuilder();
    if (value instanceof NumericValue) {
      final NumericValue numericValue = (NumericValue) value;
      float floatValue = numericValue.getValue().get().floatValue();
      if (floatValue < 0.0) {
        name.append(NEGATIVE);
        floatValue = Math.abs(floatValue);
      }
      name.append("_");
      // Replace dot with underscore, i.e., 0.45 will be converted to 0_45.
      name.append(Float.toString(floatValue).replace(".", "_"));

    }
    if (value instanceof BooleanValue) {
      name.append("_").append(value.toString());
    }
    return name.toString();
  }

  /**
   * Generates a new variable to which the expected value is assigned. The variable being
   * generated is also randomly chosen whether it would be available at the local or global scope.
   *
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param currentFunction    a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.*
   * @return the variable identifier expression of the declared variable generated by this method.
   */
  private Expr generateVariableFact(Value value,
                                    FactManager factManager,
                                    FunctionDefinition currentFunction,
                                    Stmt stmtToInsertBefore) {
    boolean atGlobalScope = factManager.globalScope() || generator.nextBoolean();
    final String varName = genVarName(value, atGlobalScope);
    final Expr initializer = generateExpr(atGlobalScope ? globalFactManager : factManager,
        currentFunction, stmtToInsertBefore, value);
    // If generating global scope variables, initialisation would be performed later in a global
    // initializer function.
    final VariableDeclInfo variableDeclInfo = new VariableDeclInfo(varName, null,
        atGlobalScope ? null : new Initializer(initializer));
    final VariablesDeclaration variablesDecl = new VariablesDeclaration(value.getType(),
        variableDeclInfo);
    final VariableDeclFact variableDeclFact = new VariableDeclFact(variablesDecl,
        variableDeclInfo, value);

    if (atGlobalScope) {
      // Search for an existing function for initialization of global variables. If not found, we
      // have to create one and add a call to the top of 'main' to invoke it.
      Optional<FunctionDefinition> maybeInitGlobalsFunction =
          translationUnit.getTopLevelDeclarations()
              .stream()
              .filter(item -> item instanceof FunctionDefinition)
              .map(item -> (FunctionDefinition) item)
              .filter(item -> item.getPrototype().getName().equals(Constants.GLF_INIT_GLOBALS))
              .findFirst();

      FunctionDefinition initGlobalsFunction;
      if (maybeInitGlobalsFunction.isPresent()) {
        initGlobalsFunction = maybeInitGlobalsFunction.get();
      } else {
        // Function prototype of the globals initializer, this must be declared at the top level of
        // the shader being generated.
        final FunctionPrototype functionPrototype =
            new FunctionPrototype(Constants.GLF_INIT_GLOBALS, VoidType.VOID,
                new ArrayList<>());
        translationUnit.addDeclarationBefore(functionPrototype, translationUnit.getMainFunction());

        // The invocation to the globals initializer which needs to be inserted as the first
        // statement in main function.
        translationUnit.getMainFunction().getBody().insertStmt(0,
            new ExprStmt(new FunctionCallExpr(Constants.GLF_INIT_GLOBALS, new ArrayList<>())));

        // A function into which the assignments of values for global variables are injected.
        initGlobalsFunction = new FunctionDefinition(functionPrototype,
            new BlockStmt(new ArrayList<>(), false));
        final List<Declaration> newTopLevelDeclarations = new ArrayList<>();
        newTopLevelDeclarations.addAll(translationUnit.getTopLevelDeclarations());
        newTopLevelDeclarations.add(initGlobalsFunction);
        translationUnit.setTopLevelDeclarations(newTopLevelDeclarations);
      }

      // Inject a statement assigning value to the global variable into function body.
      initGlobalsFunction.getBody().addStmt(new ExprStmt(new BinaryExpr(
          new VariableIdentifierExpr(varName), initializer, BinOp.ASSIGN
      )));

      translationUnit.addDeclarationBefore(variablesDecl, currentFunction);
      globalFactManager.addVariableFact(value, variableDeclFact);
    } else {
      currentFunction.getBody().insertBefore(stmtToInsertBefore,
          new DeclarationStmt(variablesDecl));
      factManager.addVariableFact(value, variableDeclFact);
    }
    return new VariableIdentifierExpr(varName);
  }

  /**
   * Generates a new function that guarantees to return the value representing the expected Value.
   * A number and type of the function arguments for the function being generated are randomized.
   *
   * @param value              the value that will be computed by the expression generated by
   *                           this method.
   * @param factManager        manager class holding the value and its associated expression that
   *                           guarantees to compute the given value.
   * @param currentFunction    a function into which the new expression will be injected.
   * @param stmtToInsertBefore statement in the body of the given function where the generated
   *                           expression will be inserted before.
   * @return function call expression of the function generated by this method.
   */
  private Expr generateFunctionFact(Value value,
                                    FactManager factManager,
                                    FunctionDefinition currentFunction,
                                    Stmt stmtToInsertBefore) {
    final String functionName = genFunctionName(value);
    final FactManager newFunctionScope = globalFactManager.newScope();
    final List<Value> argumentValues = new ArrayList<>();
    final List<ParameterDecl> parameterDecls = new ArrayList<>();

    final int noOfParams = generator.nextInt(MAX_FUNCTION_PARAMS);
    for (int i = 0; i < noOfParams; i++) {
      final Type paramType = getAvailableTypes().get(generator.nextInt(getAvailableTypes().size()));
      // Decide whether the value generated should be known by the fact manager.
      // If the fact manager is generating an unknown parameter(value is Optional.empty),
      // when calling this function the fact manager will generate any arbitrary value that
      // matches the parameter type.
      final Value paramValue = fuzzValue(paramType);
      final String paramName = genParamName(paramValue);

      argumentValues.add(paramValue);
      final ParameterDecl parameterDecl = new ParameterDecl(
          paramName,
          paramType,
          null
      );
      parameterDecls.add(parameterDecl);
      newFunctionScope.addVariableFact(paramValue, new ParameterDeclFact(parameterDecl,
          paramValue));
    }
    final BlockStmt body = new BlockStmt(Collections.emptyList(), false);
    final FunctionPrototype functionPrototype = new FunctionPrototype(functionName,
        value.getType(), parameterDecls);
    final FunctionDefinition newFunction = new FunctionDefinition(functionPrototype,
        body);
    translationUnit.addDeclarationBefore(newFunction, currentFunction);

    // Since the new function has an empty body, we first need to add a placeholder statement
    // into the body to be the point in a function where the new expressions can be injected
    // before.
    final Stmt placeholderStmt = new NullStmt();
    body.addStmt(placeholderStmt);

    // We then replace the placeholder statement with a new return statement, returning a
    // newly-generated expression.
    body.replaceChild(placeholderStmt, new ReturnStmt(
        generateExpr(
            newFunctionScope,
            newFunction,
            placeholderStmt,
            value
        )
    ));

    globalFactManager.addFunctionFact(value, new FunctionFact(functionPrototype, argumentValues,
        value));
    final List<Expr> args = generateArgsForFunctionCall(factManager, currentFunction,
        stmtToInsertBefore,
        argumentValues);
    return new FunctionCallExpr(functionName, args);
  }

  private List<? extends Type> getAvailableTypes() {
    // We will have to consider supporting more types but at the moment as we are using
    // LiteralFuzzer to generate literal expressions so we are unable to cover all basic type now.
    // The following are types currently supported by LiteralFuzzer.
    return Arrays.asList(BasicType.BOOL, BasicType.INT, BasicType.FLOAT, BasicType.VEC2,
        BasicType.VEC3, BasicType.VEC4);
  }

  private Value fuzzValue(Type type) {
    // An Unknown value variable is the variable whose value could be anything. The fact manager
    // could generate any arbitrary value but with the correct type.
    final boolean isUnknown = generator.nextBoolean();
    if (type == BasicType.BOOL) {
      return new BooleanValue(
          isUnknown ? Optional.empty() : Optional.of(generator.nextBoolean()));
    }
    if (BasicType.allScalarTypes().contains(type)) {
      if (isUnknown) {
        return new NumericValue((BasicType) type, Optional.empty());
      }
      if (type == BasicType.INT) {
        final String intString = String.valueOf(generator.nextInt(INT_MAX - INT_MIN) + INT_MIN);
        return new NumericValue(BasicType.INT, Optional.of(Integer.valueOf(intString)));
      }
      if (type == BasicType.FLOAT) {
        final String floatString = LiteralFuzzer.randomFloatString(generator);
        return new NumericValue(BasicType.FLOAT, Optional.of(Float.valueOf(floatString)));
      }
      if (type == BasicType.UINT) {
        final String intString = String.valueOf(generator.nextInt(INT_MAX - INT_MIN) + INT_MIN);
        return new NumericValue(BasicType.UINT, Optional.of(Math.abs(Integer.valueOf(intString))));
      }
      throw new RuntimeException("Not implemented yet!");
    }

    if (isUnknown) {
      return new CompositeValue(type, Optional.empty());
    }
    if (BasicType.allBasicTypes().contains(type)) {
      final List<Value> values = new ArrayList<>();
      for (int i = 0; i < ((BasicType) type).getNumElements(); i++) {
        values.add(fuzzValue(((BasicType) type).getElementType()));
      }
      return new CompositeValue(type, Optional.of(values));
    }

    // TODO(https://github.com/google/graphicsfuzz/issues/664): we should also support array and
    //  struct types as well.
    throw new RuntimeException("Not implemented yet!");
  }

}
