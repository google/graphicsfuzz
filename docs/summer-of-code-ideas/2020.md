# Google Summer of Code ideas for 2020

**Important note for Summer of Code applicants:** When getting in touch with us,
please understand that we will not reply to generic emails.
We welcome your *specific* questions, ideas, and feedback.

Please also see the [GSoC student guide](https://google.github.io/gsocguides/student/), in
particular [how to make first
contact](https://google.github.io/gsocguides/student/making-first-contact).

Also check out these previous reports from students who successfully completed GSoC with us in the past:

- [Abel Briggs](https://gist.github.com/abelbriggs1/ce2d56fd3264d4b1f0e7a248ae251179)
- [Jiradet Ounjai](https://gist.github.com/jiradeto/36b28fbc3d2596f218efc98e069786f6)

We look forward to working with you!

## Extend the reach of spirv-fuzz through new transformations and shaders

### Description

[spirv-fuzz](https://github.com/KhronosGroup/SPIRV-Tools#fuzzer) is a tool (written in C++) for automatically testing shader compilers in Vulkan graphics drivers.  Vulkan's shading language is SPIR-V, which is a little bit like LLVM bitcode, but simpler.  spirv-fuzz's aim is to generate interesting SPIR-V shaders that can trigger bugs in drivers, so that they can be fixed.

> Try our [spirv-fuzz walkthrough](../finding-a-vulkan-driver-bug-using-spirv-fuzz.md) that can be run from your browser

The tool is part of the [Khronos SPIRV-Tools](https://github.com/KhronosGroup/SPIRV-Tools) open source repository.  spirv-fuzz works by taking an input shader and repeatedly applying *semantics-preserving transformations* to it - transformations that radically change the structure of the shader, but do *not* change what the shader computes.  Two examples are:

- **Function outlining:** a region of code from a function is pulled out into its own function, and the original region is replaced with a call to that function
- **Code injection:** functions from a different SPIR-V module are “donated” to the module being transformed, and calls into these functions are added, with care being taken to ensure that the new calls do not mess up the original behaviour of the shader

The Android Graphics Tools Team are using spirv-fuzz to find bugs in a wide range of Vulkan graphics drivers.

A strength of spirv-fuzz is that it can work on the full SPIR-V language.  This is great because it allows finding bugs ahead of time that relate to features of SPIR-V that are not yet very widely-used, but that will become important in the future.

However, spirv-fuzz only incorporates a limited set of transformations, and we have only applied spirv-fuzz to shaders generated by the [glslang](https://github.com/KhronosGroup/glslang) front-end, which turns shaders written in the OpenGL shading language into SPIR-V.  It would be great to have a richer set of transformations, and to apply spirv-fuzz to SPIR-V coming from other sources.

This project thus has two aspects:

- **Adding new transformations to spirv-fuzz to find more shader compiler bugs**.  This would involve learning the SPIR-V language, and devising and implementing interesting semantics-preserving transformations.
- **Hooking spirv-fuzz up to other GPU programming language front-ends that generate SPIR-V**, such as the [DXC](https://github.com/microsoft/DirectXShaderCompiler) compiler, which generates SPIR-V from Microsoft's HLSL shading language, the [clspv](https://github.com/google/clspv) compiler, which generates SPIR-V from OpenCL kernels, and projects such as [Skia](https://github.com/google/skia) and [Filament](https://github.com/google/filament), which have their own custom SPIR-V code generators.

The two aspects of this project are connected, because some transformations might only be applicable in the presence of particular flavours of SPIR-V, so having more sources of SPIR-V available provides more opportunities for devising and implementing transformations.

We would be interested in mentoring a GSoC project devoted exclusively to one or other of the above aspects, or to their combination.

### Expected outcomes

The project would deliver either or both of:

- New SPIR-V transformations implemented in the spirv-fuzz tool
- Tooling to hook SPIR-V fuzz up to at least one language front-end, such as DXC or clspv

In addition, the project would probably lead to finding and reporting several shader compiler bugs in open source Vulkan drivers (such as [Mesa](https://www.mesa3d.org/) or [SwiftShader](https://github.com/google/swiftshader)), as well as to general improvements to the spirv-fuzz tool itself.

### Required skills

- Strong C++ programming skills are an essential prerequisite for the project.

A student with existing experience with compiler frameworks, or with knowledge of graphics shading languages, would have a head start, but these are not required skills.

### Possible mentors

Alastair Donaldson (primary), Paul Thomson (secondary).

### Difficulty rating

Medium.


## Contribute Vulkan sample apps

### Description

Most of the tools developed by the Android Graphics Tools team are related to the Vulkan graphics API. We use Vulkan sample apps to test our own tools. Many of these apps come from open-source projects, such as [Sascha Willems demos](https://github.com/SaschaWillems/Vulkan), [Khronos Vulkan samples](https://github.com/KhronosGroup/Vulkan-Samples) or [Google Vulkan test applications](https://github.com/google/vulkan_test_applications).


The goal of this project is to create Vulkan samples that, compared to existing sample apps, exercise new corners of the Vulkan API, or new combinations of features. In order to know which parts of the Vulkan API are not yet covered we can do coverage analysis of our own projects (e.g. [GAPID](https://github.com/google/gapid)), or of open-source Vulkan drivers (e.g. [Mesa](https://www.mesa3d.org/)) and look for coverage gaps.

This is a great opportunity to learn about graphics programming in general and Vulkan programming in particular.  Moreover, contributing new Vulkan samples will benefit not only the Android Graphics Tools team, but also the wider Vulkan ecosystem.

### Expected outcomes

By the end of the project, the student should have contributed at least one Vulkan sample app using some feature of the Vulkan API not exercised by the [Sascha Willems](https://github.com/SaschaWillems/Vulkan), [Khronos](https://github.com/KhronosGroup/Vulkan-Samples) or [Google](https://github.com/google/vulkan_test_applications) Vulkan sample apps. The sample(s) will be added to either the Google Vulkan test apps repo or the [GraphicsFuzz](https://github.com/google/graphicsfuzz) repo.

The project is open-ended; the student can contribute as many relevant Vulkan samples as feasible.

### Required skills

- Strong C/C++ programming skills

Experience with graphics APIs such as OpenGL or Vulkan would be useful but is not required.

### Possible mentors

Hugues Evrard (primary), Alastair Donaldson (secondary).

### Difficulty rating

Medium




## LibFuzzer custom mutator based on spirv-fuzz

### Description

[libFuzzer](https://llvm.org/docs/LibFuzzer.html) is a general-purpose, coverage-guided, in-process fuzzing engine written in C++. Given a target function that you want to test (e.g. your PNG image decoding function), libFuzzer repeatedly invokes the target function with different inputs (e.g. PNG image files, including invalid PNG files) so that more and more of the code in your target function is exercised. libFuzzer is infamous in its ability to uncover [security bugs](https://llvm.org/docs/LibFuzzer.html#trophies), such as out of bound memory accesses. libFuzzer starts with a corpus of existing inputs that are treated as arrays of bytes; these are then repeatedly mutated to find new, interesting inputs. The fact that libFuzzer does not _understand_ the inputs can result in inefficient fuzzing for complicated input types.

[spirv-fuzz](https://github.com/KhronosGroup/SPIRV-Tools#fuzzer) is our fuzzer for Vulkan graphics drivers written in C++. Unlike the general purpose libFuzzer, spirv-fuzz is _specialized_ to operate only on graphics shaders (programs that run on the GPU to render hardware-accelerated graphics) written in Vulkan's shader language, SPIR-V. spirv-fuzz _understands_ its inputs and mutates them such that they remain valid. Furthermore, spirv-fuzz typically applies hundreds of transformations to an existing input before running the input on the target Vulkan driver, as the mutation process is more expensive. spirv-fuzz is also not coverage-guided.

> Try our [spirv-fuzz walkthrough](../finding-a-vulkan-driver-bug-using-spirv-fuzz.md) that can be run from your browser

This project would involve writing a custom mutator (in C++) for libFuzzer that delegates the mutation of an input to spirv-fuzz. This would allow using spirv-fuzz's powerful mutation functions with libFuzzer's coverage-based fuzzing approach. It may also be useful to add new mutation functions to spirv-fuzz that work well with coverage-guided fuzzing. The project would also involve integrating the custom-mutator into several test targets containing other open source projects, such as: [spirv-val](https://github.com/KhronosGroup/SPIRV-Tools#validator) (a validator for SPIR-V), [spirv-opt](https://github.com/KhronosGroup/SPIRV-Tools#optimizer) (an optimizer for SPIR-V), [AMD LLPC](https://github.com/GPUOpen-Drivers/llpc) (AMD's open source, LLVM-based SPIR-V shader compiler, used by its open source Vulkan driver [AMDVLK](https://github.com/GPUOpen-Drivers/AMDVLK)), and [SwiftShader](https://github.com/google/swiftshader) (a software Vulkan driver). The test targets should eventually be set up to run continuously in [OSS-Fuzz](https://github.com/google/oss-fuzz), Google's open source “fuzzing as a service” infrastructure; this service will continuously build the latest versions of each test target, continuously fuzz the targets, and automatically de-duplicate and report bugs to the relevant open source projects.



### Expected outcomes

The student would deliver:

- A custom mutator for [libFuzzer](https://llvm.org/docs/LibFuzzer.html) that uses [spirv-fuzz](https://github.com/KhronosGroup/SPIRV-Tools#fuzzer).
- A number of test targets that integrate the new mutator, libFuzzer, and a target application.
- A number of new projects added to the [OSS-Fuzz](https://github.com/google/oss-fuzz) GitHub repository so that the relevant open source projects are continuously being fuzzed in the cloud.

The student _might_ also deliver:

- A number of new mutation functions in the [spirv-fuzz](https://github.com/KhronosGroup/SPIRV-Tools#fuzzer) tool.

In addition, the project would most likely lead to finding and reporting many bugs in open source projects, such as [SPIRV-Tools](https://github.com/KhronosGroup/SPIRV-Tools), [LLPC](https://github.com/GPUOpen-Drivers/llpc), and [SwiftShader](https://github.com/google/swiftshader).

### Required skills

* C++ programming.

### Possible mentors

Paul Thomson (primary), Alastair Donaldson (secondary)

### Difficulty rating

Medium




## Making GraphicsFuzz smarter

### Description

[GraphicsFuzz](https://github.com/google/graphicsfuzz) is a mature tool (written in Java) for automatically finding bugs in graphics drivers.  It was the basis of two successful 2019 GSoC projects, by Abel Briggs and Jiradet Ounjai.

GraphicsFuzz takes an existing shader written in GLSL (the OpenGL Shading Language), parses it, mutates it, and outputs a much more complex “variant” shader that should have the same behavior as the original. The variant shader is harder for the graphics driver to process and can lead to crashes or the wrong image being rendered. The approach is similar to that used by spirv-fuzz, described in the first project above: a series of semantics-preserving transformations are applied to the shader to make it very different from the shader compiler's perspective, but to preserve the result that it produces.  This means that bugs can be found by comparing the image rendered by an original shader and a transformed variant of that shader.

GraphicsFuzz is being used to continuously test Vulkan graphics drivers for Android and other platforms.  This has identified several ways in which the tool could be made smarter, including:

De-duplication of bug reports.  When GraphicsFuzz finds a GLSL shader that triggers a bug, an important question is: how likely is it that the bug is new, i.e. different from bugs we already know about?  For some kinds of bugs this is easy - for example, when a driver crashes we can use the stack trace of the crash to get a pretty good handle on bug uniqueness.  But for bugs that lead to bad images being rendered, or where shader compilation exits with an opaque message such as “SHADER COMPILATION FAILED”, it is challenging to figure out whether a new bug, or a duplicate of a known bug, has been found.  We are interested in investigating *shader similarity metrics* for comparing two GLSL shaders and thus estimating the likelihood that a bug-inducing shader triggers a new bug.  This could involve analysing the abstract syntax tree of two shaders to decide how likely they are to be similar (after some renaming of variables), or could involve running the shaders through [SwiftShader](https://github.com/google/swiftshader) and gathering some information about their runtime behaviour.
Better support for shading language features.  GraphicsFuzz is currently heavily tuned towards transforming fragment shaders.  The tool has limited support for vertex shaders and compute shaders, and there is scope for increasing the kinds of shader compiler bugs that could be found by improving support for other shader kinds.
Improving GraphicsFuzz with new transformations and bug fixes.  The GraphicsFuzz issue tracker contains many ideas for how to increase the reach of GraphicsFuzz via adding new transformations, generalising existing transformations, and fixing known limitations.

### Expected outcomes

A successful project in this area would involve making a series of pull requests to [GraphicsFuzz](https://github.com/google/graphicsfuzz) to contribute to one or more of the above topics, for example adding a new approach to bug de-duplication, adding support for a missing shading language feature, or adding a new transformation to the tool.

Throughout the project, the student would test their contributions by running GraphicsFuzz on a range of Vulkan graphics drivers.  This would likely lead to the discovery of a number of bugs that could be reported to open source Vulkan projects, such as [Mesa](https://www.mesa3d.org/) and [SwiftShader](https://github.com/google/swiftshader).

### Required skills

Strong Java programming skills are an essential prerequisite.

Some familiarity with compiler frameworks and/or graphics programming models would give the student a head start, but are not required.

### Possible mentors

Alastair Donaldson (primary).  Paul Thomson (secondary).

### Difficulty rating

Medium, with flexibility (an ambitious student could tackle very sophisticated new transformations in GraphicsFuzz, and there is also scope for focusing on addressing a series of easy, yet important, issues with the tool).
